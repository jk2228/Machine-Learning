{"ts":1347910773750,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"import math\nfrom operator import itemgetter\nimport sys\n\n\nclass DataPoint:\n    def __init__(self, loc, stats):\n        self.location = loc\n        self.stations = stats\n\n    def __repr__(self):\n        return '\\n' + str(self.stations) + '   ' + self.location\n\nclass Node:\n    def __init__(self, left, right, dataPoints, attribute, value):\n        self.left = left\n        self.right = right\n        self.dataPoints = dataPoints\n        self.attr = attribute\n        self.value = value\n        \n        locSums = {}\n\n        for point in dataPoints:\n            if point.location not in locSums:\n                locSums[point.location] = 0\n            locSums[point.location] += 1\n\n        self.locSums = locSums\n        self.entropy = getEntropy(locSums.values())\n\n#Load training data\n\ndef loadTrainingData():\n    f = open('wifi.train', 'ru')\n         \n    lines = f.readlines()\n    data = []\n\n    for line in lines:\n        tokens = line.split(' ')\n        allTokens = []\n        for t in tokens:\n            subdivision = t.split(':')\n            for s in subdivision:\n                if s != \"\":\n                    allTokens.append(s)\n        i = 0\n        loc = \"\"\n        stat = {}\n        for token in allTokens:\n            if i == (len(allTokens)-1):\n                loc = token.replace('\\n','')\n            elif i % 2 == 1: # if odd\n                stat[int(allTokens[i-1])] = int(allTokens[i])\n            i += 1\n\n        for i in range(0, 10):\n            if i not in stat:\n                stat[i] = -1 * sys.maxint\n        data.append(DataPoint(loc, stat))\n\n    return data\n\ndef getEntropy(numbers):\n    sum = float(0)\n    for n in numbers:\n        sum += n\n\n    totalEntropy = 0\n    for n in numbers:\n        if n == 0:\n            continue\n        nn = float(n)\n        entropy = (nn/sum)*(-1 * math.log(nn/sum))\n        totalEntropy += entropy\n\n    return totalEntropy\n\ndef getAttributeLists(dataList):\n    splitsForAttributes = {}\n\n    for point in dataList:\n        for station in point.stations:\n            if station not in splitsForAttributes:\n                splitsForAttributes[station] = []\n            splitsForAttributes[station].append( (point.stations[station], point.location) )\n\n    for list in splitsForAttributes:\n        splitsForAttributes[list] = sorted(splitsForAttributes[list], key=itemgetter(0))\n\n    return splitsForAttributes\n\ndef getSplits(attributeLists):\n    splits = {}\n    for attr in attributeLists:\n        splitList = []\n        prev = attributeLists[attr][0]\n        \n        print attributeLists[attr]\n        for pair in attributeLists[attr]:\n            value, loc = pair\n            pValue, pLoc = prev\n            if loc != pLoc:\n                print value\n                splitList.append((value + pValue) / float(2))\n            prev = pair\n        splits[attr] = list(set(splitList))\n\n    return splits\n\ndef splitNode(node):\n    lPoints = []\n    rPoints = []\n    rPoints = filter(lambda x: (x.stations[node.attr] >= node.value), node.dataPoints)\n    lPoints = filter(lambda x: (x.stations[node.attr] < node.value), node.dataPoints)\n    \n    lChild = Node(None, None, lPoints, None, None)\n    rChild = Node(None, None, rPoints, None, None)\n\n    node.left = lChild\n    node.right = rChild\n\n    return node\n\ndef getChildrenEntropy(rootNode):\n    # Return weighted sum of children entropies\n    r = rootNode.right.entropy * (float(len(rootNode.right.dataPoints)) / len(rootNode.dataPoints))\n    l = rootNode.left.entropy * (float(len(rootNode.left.dataPoints)) / len(rootNode.dataPoints))\n    \n    return r + l\n\n   \n\n\ndataPoints = loadTrainingData()\nnode = Node(None, None, dataPoints, 0, -80)\nprint node.locSums\nprint node.entropy\n\nprint getChildrenEntropy(splitNode(node))\n"]],"start1":0,"start2":0,"length1":0,"length2":3730}]],"length":3730}
